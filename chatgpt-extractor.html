<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ChatGPT Export Extractor ‚Äì Nebula Ultimate</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <meta name="description" content="Extract and analyze your ChatGPT conversation exports. Free, client-side tool with multi-format export support.">
  <meta name="keywords" content="ChatGPT, export, extractor, conversation, analysis, JSON, markdown">
  <meta name="theme-color" content="#0b1124">
  <link rel="manifest" href="manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="ChatGPT Extractor">
  <style>
    body { font-family: 'Segoe UI', Arial, sans-serif; background: #0b1124; color: #e3eaff; margin: 0; }
    .container { max-width: 1200px; margin: auto; padding: 2rem; }
    h1 { color: #50b6ff; }
    h2 { color: #ffe488; margin-top: 2em; }
    p { font-size: 1.05em; line-height: 1.8; }
    .upload-section { background: #1a2642; padding: 2rem; border-radius: 8px; margin: 2rem 0; }
    .btn { background: #50b6ff; color: #0b1124; padding: 0.8em 2em; border-radius: 6px; font-weight: bold; cursor: pointer; border: none; font-size: 1em; transition: 0.3s; }
    .btn:hover { background: #70c6ff; }
    .btn:disabled { background: #444; cursor: not-allowed; }
    .file-input { display: none; }
    .file-label { display: inline-block; background: #50b6ff; color: #0b1124; padding: 0.8em 2em; border-radius: 6px; font-weight: bold; cursor: pointer; transition: 0.3s; }
    .file-label:hover { background: #70c6ff; }
    .status { margin-top: 1em; padding: 1em; border-radius: 6px; display: none; }
    .status.success { background: #1a4d2e; color: #6ef2a8; display: block; }
    .status.error { background: #4d1a1a; color: #f28686; display: block; }
    .status.info { background: #2a3a5a; color: #a8c7f2; display: block; }
    .conversation-list { margin-top: 2rem; }
    .conversation-item { background: #1a2642; padding: 1.5rem; margin: 1rem 0; border-radius: 8px; border-left: 4px solid #50b6ff; }
    .conversation-title { color: #ffe488; font-size: 1.2em; font-weight: bold; margin-bottom: 0.5em; }
    .conversation-meta { color: #888; font-size: 0.9em; margin-bottom: 1em; }
    .message { margin: 1em 0; padding: 1em; border-radius: 6px; }
    .message.user { background: #2a3a5a; border-left: 3px solid #50b6ff; }
    .message.assistant { background: #1e2d45; border-left: 3px solid #ffe488; }
    .message.system { background: #2d1e45; border-left: 3px solid #b488ff; }
    .message-role { font-weight: bold; color: #ffe488; margin-bottom: 0.5em; text-transform: uppercase; font-size: 0.85em; }
    .message-content { line-height: 1.6; }
    .message-content pre { background: #0d1627; padding: 1em; border-radius: 4px; overflow-x: auto; }
    .message-content code { background: #222e44; padding: 0.2em 0.4em; border-radius: 3px; color: #ffe488; }
    .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 2rem 0; }
    .stat-box { background: #1a2642; padding: 1.5rem; border-radius: 8px; text-align: center; }
    .stat-value { font-size: 2em; color: #50b6ff; font-weight: bold; }
    .stat-label { color: #888; margin-top: 0.5em; }
    .export-options { margin: 2rem 0; display: flex; gap: 1rem; flex-wrap: wrap; }
    .search-box { width: 100%; padding: 0.8em; border-radius: 6px; border: 2px solid #2a3a5a; background: #1a2642; color: #e3eaff; font-size: 1em; margin: 1rem 0; }
    .search-box:focus { outline: none; border-color: #50b6ff; }
    .back-link { color: #50b6ff; text-decoration: none; display: inline-block; margin-bottom: 1em; }
    .back-link:hover { text-decoration: underline; }
    .footer { margin-top: 3em; padding-top: 2em; border-top: 1px solid #2a3a5a; color: #888; font-size: 0.9em; text-align: center; }
    .instructions { background: #1a2642; padding: 1.5rem; border-radius: 8px; margin: 2rem 0; border-left: 4px solid #ffe488; }
    .instructions ol { margin: 1em 0; padding-left: 1.5em; }
    .instructions li { margin: 0.5em 0; line-height: 1.6; }
    .demo-btn { background: #ffe488; color: #0b1124; margin-left: 1em; }
    .demo-btn:hover { background: #ffed9f; }
    /* Accessibility improvements */
    .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0,0,0,0); border: 0; }
    .btn:focus, .file-label:focus, .search-box:focus { outline: 3px solid #50b6ff; outline-offset: 2px; }
    .skip-link { position: absolute; top: -40px; left: 0; background: #50b6ff; color: #0b1124; padding: 8px; z-index: 100; }
    .skip-link:focus { top: 0; }
    /* Language selector */
    .lang-selector { position: absolute; top: 1rem; right: 1rem; }
    .lang-selector select { background: #1a2642; color: #e3eaff; border: 2px solid #2a3a5a; border-radius: 6px; padding: 0.5em 1em; cursor: pointer; }
    .lang-selector select:focus { outline: none; border-color: #50b6ff; }
    /* Pagination */
    .pagination { display: flex; justify-content: center; align-items: center; gap: 1rem; margin: 2rem 0; flex-wrap: wrap; }
    .pagination button { min-width: 80px; }
    .pagination-info { color: #888; font-size: 0.9em; }
    .per-page-selector { display: flex; align-items: center; gap: 0.5rem; margin: 1rem 0; }
    .per-page-selector select { background: #1a2642; color: #e3eaff; border: 2px solid #2a3a5a; border-radius: 6px; padding: 0.5em; }
    /* Loading indicator */
    .loading { text-align: center; padding: 2rem; }
    .spinner { border: 4px solid #2a3a5a; border-top: 4px solid #50b6ff; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    /* Responsive design */
    @media (max-width: 600px) { 
      .container { padding:1em; } 
      h1 {font-size:1.3em;} 
      .stats { grid-template-columns: 1fr; }
      .export-options { flex-direction: column; }
      .export-options .btn { width: 100%; }
      .lang-selector { position: static; margin-bottom: 1rem; }
      .demo-btn { margin-left: 0; margin-top: 1em; display: block; width: 100%; }
    }
    /* Print styles */
    @media print {
      .upload-section, .export-options, .search-box, .back-link, .lang-selector, .pagination { display: none; }
      body { background: white; color: black; }
      .conversation-item { page-break-inside: avoid; }
    }
  </style>
</head>
<body>
  <a href="#main-content" class="skip-link">Skip to main content</a>
  <div class="container">
    <div class="lang-selector">
      <label for="languageSelect" class="visually-hidden">Language</label>
      <select id="languageSelect" aria-label="Select language">
        <option value="en">English</option>
        <option value="es">Espa√±ol</option>
        <option value="fr">Fran√ßais</option>
      </select>
    </div>
    <a href="index.html" class="back-link" aria-label="Go back to Nebula Ultimate homepage">‚Üê <span data-i18n="backLink">Back to Nebula Ultimate</span></a>
    <h1 id="main-content" data-i18n="title">ChatGPT Export Extractor</h1>
    <p><strong>Extract and analyze your ChatGPT conversation exports</strong></p>
    <p>Upload your ChatGPT export file (conversations.json) to parse, view, and export your conversation data in various formats.</p>

    <div class="instructions">
      <h2>üì• How to Export Your ChatGPT Conversations</h2>
      <ol>
        <li>Go to <strong>ChatGPT</strong> (chat.openai.com)</li>
        <li>Click on your <strong>profile icon</strong> in the bottom left corner</li>
        <li>Select <strong>"Settings"</strong> from the menu</li>
        <li>Go to <strong>"Data controls"</strong> ‚Üí <strong>"Export data"</strong></li>
        <li>Click <strong>"Export"</strong> and wait for the email with your download link</li>
        <li>Download the ZIP file, extract it, and find <strong>conversations.json</strong></li>
        <li>Upload the conversations.json file below!</li>
      </ol>
    </div>

    <div class="upload-section">
      <h2>Upload ChatGPT Export</h2>
      <input type="file" id="fileInput" class="file-input" accept=".json" />
      <label for="fileInput" class="file-label">Choose File</label>
      <button class="btn demo-btn" onclick="loadDemoData()">Try Demo Data</button>
      <span id="fileName" style="margin-left: 1em; color: #888;">No file selected</span>
      <div id="status" class="status"></div>
    </div>

    <div id="statsSection" style="display: none;">
      <h2>Export Statistics</h2>
      <div class="stats">
        <div class="stat-box">
          <div class="stat-value" id="totalConversations">0</div>
          <div class="stat-label">Total Conversations</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="totalMessages">0</div>
          <div class="stat-label">Total Messages</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="userMessages">0</div>
          <div class="stat-label">User Messages</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="assistantMessages">0</div>
          <div class="stat-label">Assistant Responses</div>
        </div>
      </div>

      <h2>Export Options</h2>
      <div class="export-options">
        <button class="btn" onclick="exportAsJSON()">Export as JSON</button>
        <button class="btn" onclick="exportAsText()">Export as Text</button>
        <button class="btn" onclick="exportAsMarkdown()">Export as Markdown</button>
        <button class="btn" onclick="exportAsHTML()">Export as HTML</button>
      </div>

      <h2>Search Conversations</h2>
      <input type="text" id="searchBox" class="search-box" placeholder="Search conversations by title or content..." 
             aria-label="Search conversations" />
      
      <div class="per-page-selector" id="perPageSection" style="display: none;">
        <label for="perPageSelect">Per page:</label>
        <select id="perPageSelect" aria-label="Results per page">
          <option value="10">10</option>
          <option value="25" selected>25</option>
          <option value="50">50</option>
          <option value="100">100</option>
        </select>
      </div>
    </div>

    <div class="pagination" id="paginationTop" style="display: none;" role="navigation" aria-label="Pagination">
      <button class="btn" id="prevPageTop" aria-label="Previous page">Previous</button>
      <span class="pagination-info" id="paginationInfoTop" aria-live="polite"></span>
      <button class="btn" id="nextPageTop" aria-label="Next page">Next</button>
    </div>

    <div id="conversationList" class="conversation-list" role="main" aria-live="polite" aria-atomic="false"></div>

    <div class="pagination" id="paginationBottom" style="display: none;" role="navigation" aria-label="Pagination">
      <button class="btn" id="prevPageBottom" aria-label="Previous page">Previous</button>
      <span class="pagination-info" id="paginationInfoBottom" aria-live="polite"></span>
      <button class="btn" id="nextPageBottom" aria-label="Next page">Next</button>
    </div>

    <div class="footer">
      ChatGPT Export Extractor ‚Äì Part of Nebula Ultimate<br>
      Extract, analyze, and export your ChatGPT conversations with ease
    </div>
  </div>

  <script src="i18n.js"></script>
  <script src="chatgpt-extractor-core.js"></script>
  <script>
    let conversationsData = [];
    let filteredConversations = [];
    let currentPage = 1;
    let perPage = 25;

    const fileInput = document.getElementById('fileInput');
    const fileName = document.getElementById('fileName');
    const status = document.getElementById('status');
    const searchBox = document.getElementById('searchBox');
    const languageSelect = document.getElementById('languageSelect');
    const perPageSelect = document.getElementById('perPageSelect');

    // Initialize language
    if (typeof i18n !== 'undefined') {
      languageSelect.value = i18n.getLanguage();
      updateUILanguage();
      languageSelect.addEventListener('change', handleLanguageChange);
    }

    // Event listeners
    fileInput.addEventListener('change', handleFileSelect);
    searchBox.addEventListener('input', handleSearch);
    perPageSelect.addEventListener('change', handlePerPageChange);
    
    // Pagination event listeners
    ['prevPageTop', 'prevPageBottom'].forEach(id => {
      document.getElementById(id)?.addEventListener('click', () => goToPage(currentPage - 1));
    });
    ['nextPageTop', 'nextPageBottom'].forEach(id => {
      document.getElementById(id)?.addEventListener('click', () => goToPage(currentPage + 1));
    });

    // Keyboard navigation
    document.addEventListener('keydown', handleKeyboardNav);

    function handleLanguageChange(event) {
      if (typeof i18n !== 'undefined') {
        i18n.setLanguage(event.target.value);
        updateUILanguage();
        if (conversationsData.length > 0) {
          displayConversations();
        }
      }
    }

    function updateUILanguage() {
      if (typeof i18n === 'undefined') return;
      
      document.querySelectorAll('[data-i18n]').forEach(element => {
        const key = element.getAttribute('data-i18n');
        element.textContent = i18n.t(key);
      });
      
      // Update placeholders and aria-labels
      if (searchBox) searchBox.placeholder = i18n.t('searchPlaceholder');
    }

    function handleKeyboardNav(event) {
      // Escape key clears search
      if (event.key === 'Escape' && document.activeElement === searchBox) {
        searchBox.value = '';
        handleSearch({ target: searchBox });
      }
    }

    function handlePerPageChange(event) {
      perPage = parseInt(event.target.value);
      currentPage = 1;
      displayConversations();
    }

    function goToPage(page) {
      const totalPages = Math.ceil(filteredConversations.length / perPage);
      if (page < 1 || page > totalPages) return;
      currentPage = page;
      displayConversations();
      // Scroll to top of conversation list
      document.getElementById('conversationList').scrollIntoView({ behavior: 'smooth' });
    }

    function updatePagination() {
      const totalPages = Math.ceil(filteredConversations.length / perPage);
      const start = (currentPage - 1) * perPage + 1;
      const end = Math.min(currentPage * perPage, filteredConversations.length);
      
      const infoText = typeof i18n !== 'undefined' 
        ? i18n.t('showingResults', { start, end, total: filteredConversations.length })
        : `Showing ${start}-${end} of ${filteredConversations.length}`;
      
      ['paginationInfoTop', 'paginationInfoBottom'].forEach(id => {
        const element = document.getElementById(id);
        if (element) element.textContent = infoText;
      });
      
      ['prevPageTop', 'prevPageBottom'].forEach(id => {
        const btn = document.getElementById(id);
        if (btn) btn.disabled = currentPage === 1;
      });
      
      ['nextPageTop', 'nextPageBottom'].forEach(id => {
        const btn = document.getElementById(id);
        if (btn) btn.disabled = currentPage === totalPages;
      });
      
      // Show/hide pagination
      const showPagination = filteredConversations.length > perPage;
      ['paginationTop', 'paginationBottom', 'perPageSection'].forEach(id => {
        const element = document.getElementById(id);
        if (element) element.style.display = showPagination ? 'flex' : 'none';
      });
    }

    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;

      fileName.textContent = file.name;
      const loadingMsg = typeof i18n !== 'undefined' ? i18n.t('loadingFile') : 'Loading file...';
      showStatus('info', loadingMsg);

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          processExportData(data);
        } catch (error) {
          const errorMsg = typeof i18n !== 'undefined'
            ? i18n.t('errorParsing', { error: error.message })
            : 'Error parsing JSON: ' + error.message;
          showStatus('error', errorMsg);
        }
      };
      reader.readAsText(file);
    }

    function processExportData(data) {
      try {
        // Use core module if available
        if (typeof ChatGPTExtractorCore !== 'undefined') {
          conversationsData = ChatGPTExtractorCore.processExportData(data);
        } else {
          // Fallback to local implementation
          conversationsData = Array.isArray(data) ? data : (data.conversations || [data]);
          if (conversationsData.length === 0) {
            throw new Error('No conversations found in the export file');
          }
        }

        filteredConversations = [...conversationsData];
        currentPage = 1; // Reset pagination
        calculateStats();
        displayConversations();
        document.getElementById('statsSection').style.display = 'block';
        
        const successMsg = typeof i18n !== 'undefined'
          ? i18n.t('successfullyLoaded', { count: conversationsData.length })
          : `Successfully loaded ${conversationsData.length} conversation(s)!`;
        showStatus('success', successMsg);
      } catch (error) {
        const errorMsg = typeof i18n !== 'undefined'
          ? i18n.t('errorProcessing', { error: error.message })
          : 'Error processing data: ' + error.message;
        showStatus('error', errorMsg);
      }
    }

    function calculateStats() {
      let totalMessages = 0;
      let userMessages = 0;
      let assistantMessages = 0;

      conversationsData.forEach(conv => {
        const messages = extractMessages(conv);
        totalMessages += messages.length;
        messages.forEach(msg => {
          if (msg.role === 'user') userMessages++;
          else if (msg.role === 'assistant') assistantMessages++;
        });
      });

      document.getElementById('totalConversations').textContent = conversationsData.length;
      document.getElementById('totalMessages').textContent = totalMessages;
      document.getElementById('userMessages').textContent = userMessages;
      document.getElementById('assistantMessages').textContent = assistantMessages;
    }

    function extractMessages(conversation) {
      // Handle different conversation structures
      if (conversation.mapping) {
        // New ChatGPT export format with mapping
        const messages = [];
        Object.values(conversation.mapping).forEach(node => {
          if (node.message && node.message.content && node.message.content.parts && node.message.author && node.message.author.role) {
            messages.push({
              role: node.message.author.role,
              content: node.message.content.parts.join('\n'),
              timestamp: node.message.create_time
            });
          }
        });
        return messages;
      } else if (conversation.messages) {
        // Simple messages array format
        return conversation.messages;
      } else if (conversation.role && conversation.content) {
        // Single message format
        return [conversation];
      }
      return [];
    }

    function getConversationTitle(conv) {
      return conv.title || conv.name || `Conversation ${conversationsData.indexOf(conv) + 1}`;
    }

    function getConversationDate(conv) {
      const timestamp = conv.create_time || conv.update_time || conv.timestamp;
      if (timestamp) {
        // Handle both Unix timestamps (seconds) and JavaScript timestamps (milliseconds)
        const date = timestamp > 10000000000 ? new Date(timestamp) : new Date(timestamp * 1000);
        return date.toLocaleString();
      }
      return 'Unknown date';
    }

    function displayConversations() {
      const listElement = document.getElementById('conversationList');
      listElement.innerHTML = '';

      if (filteredConversations.length === 0) {
        const noMatchText = typeof i18n !== 'undefined' ? i18n.t('noMatches') : 'No conversations match your search.';
        listElement.innerHTML = `<p style="text-align: center; color: #888;">${noMatchText}</p>`;
        updatePagination();
        return;
      }

      // Calculate pagination
      const startIndex = (currentPage - 1) * perPage;
      const endIndex = Math.min(startIndex + perPage, filteredConversations.length);
      const paginatedConversations = filteredConversations.slice(startIndex, endIndex);

      // Show loading indicator for large datasets
      if (filteredConversations.length > 100 && paginatedConversations.length > 0) {
        listElement.innerHTML = '<div class="loading"><div class="spinner"></div></div>';
      }

      // Use setTimeout to prevent UI blocking for large datasets
      setTimeout(() => {
        listElement.innerHTML = '';
        
        paginatedConversations.forEach((conv, index) => {
        const convElement = document.createElement('div');
        convElement.className = 'conversation-item';

        const title = getConversationTitle(conv);
        const date = getConversationDate(conv);
        const messages = extractMessages(conv);

        let messagesHTML = '';
        messages.forEach(msg => {
          if (msg.role && msg.content) {
            const contentHTML = formatContent(msg.content);
            messagesHTML += `
              <div class="message ${msg.role}">
                <div class="message-role">${msg.role}</div>
                <div class="message-content">${contentHTML}</div>
              </div>
            `;
          }
        });

        convElement.innerHTML = `
          <div class="conversation-title">${escapeHtml(title)}</div>
          <div class="conversation-meta">${date} ‚Ä¢ ${messages.length} messages</div>
          ${messagesHTML}
        `;

        listElement.appendChild(convElement);
        });
        
        updatePagination();
      }, 10); // Small delay to prevent UI blocking
    }

    function formatContent(content) {
      let formatted = escapeHtml(content);
      // Convert markdown-style code blocks - content is already escaped
      formatted = formatted.replace(/```(\w+)?\n([\s\S]*?)```/g, function(match, lang, code) {
        return '<pre><code>' + code + '</code></pre>';
      });
      // Convert inline code - content is already escaped
      formatted = formatted.replace(/`([^`]+)`/g, function(match, code) {
        return '<code>' + code + '</code>';
      });
      // Convert newlines to <br>
      formatted = formatted.replace(/\n/g, '<br>');
      return formatted;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function handleSearch(event) {
      const query = event.target.value.toLowerCase();
      
      if (!query) {
        filteredConversations = [...conversationsData];
      } else {
        // Use core module if available, otherwise use local implementation
        if (typeof ChatGPTExtractorCore !== 'undefined') {
          filteredConversations = ChatGPTExtractorCore.searchConversations(conversationsData, query);
        } else {
          filteredConversations = conversationsData.filter(conv => {
            const title = getConversationTitle(conv).toLowerCase();
            const messages = extractMessages(conv);
            const hasMatchingMessage = messages.some(msg => 
              msg.content && msg.content.toLowerCase().includes(query)
            );
            return title.includes(query) || hasMatchingMessage;
          });
        }
      }
      
      currentPage = 1; // Reset to first page on search
      displayConversations();
    }

    function showStatus(type, message) {
      status.className = `status ${type}`;
      status.textContent = message;
      status.style.display = 'block';
    }

    function exportAsJSON() {
      const dataStr = typeof ChatGPTExtractorCore !== 'undefined'
        ? ChatGPTExtractorCore.exportAsJSON(conversationsData)
        : JSON.stringify(conversationsData, null, 2);
      downloadFile(dataStr, 'chatgpt-export.json', 'application/json');
    }

    function exportAsText() {
      const text = typeof ChatGPTExtractorCore !== 'undefined'
        ? ChatGPTExtractorCore.exportAsText(conversationsData)
        : generateTextExport();
      downloadFile(text, 'chatgpt-export.txt', 'text/plain');
    }

    function generateTextExport() {
      let text = '';
      conversationsData.forEach((conv, index) => {
        text += `\n${'='.repeat(80)}\n`;
        text += `CONVERSATION ${index + 1}: ${getConversationTitle(conv)}\n`;
        text += `Date: ${getConversationDate(conv)}\n`;
        text += `${'='.repeat(80)}\n\n`;

        const messages = extractMessages(conv);
        messages.forEach(msg => {
          if (msg.role && msg.content) {
            text += `[${msg.role.toUpperCase()}]\n`;
            text += `${msg.content}\n\n`;
            text += `${'-'.repeat(40)}\n\n`;
          }
        });
      });
      return text;
    }

    function exportAsMarkdown() {
      const markdown = typeof ChatGPTExtractorCore !== 'undefined'
        ? ChatGPTExtractorCore.exportAsMarkdown(conversationsData)
        : generateMarkdownExport();
      downloadFile(markdown, 'chatgpt-export.md', 'text/markdown');
    }

    function generateMarkdownExport() {
      let markdown = '# ChatGPT Export\n\n';
      conversationsData.forEach((conv, index) => {
        markdown += `## ${getConversationTitle(conv, index)}\n\n`;
        markdown += `**Date:** ${getConversationDate(conv)}\n\n`;

        const messages = extractMessages(conv);
        messages.forEach(msg => {
          if (msg.role && msg.content) {
            markdown += `### ${msg.role.charAt(0).toUpperCase() + msg.role.slice(1)}\n\n`;
            markdown += `${msg.content}\n\n`;
            markdown += `---\n\n`;
          }
        });
        markdown += `\n`;
      });
      return markdown;
    }

    // Use core module for HTML export if available
    function exportAsHTML() {
      const html = typeof ChatGPTExtractorCore !== 'undefined'
        ? ChatGPTExtractorCore.exportAsHTML(conversationsData)
        : generateHTMLExport();
      downloadFile(html, 'chatgpt-export.html', 'text/html');
    }

    function generateHTMLExport() {
      let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ChatGPT Export</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 900px; margin: 2rem auto; padding: 0 1rem; background: #f5f5f5; }
    .conversation { background: white; padding: 2rem; margin: 2rem 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .title { font-size: 1.5em; font-weight: bold; color: #333; margin-bottom: 0.5em; }
    .meta { color: #666; margin-bottom: 1em; }
    .message { margin: 1.5em 0; padding: 1em; border-radius: 6px; }
    .user { background: #e3f2fd; border-left: 4px solid #2196F3; }
    .assistant { background: #f3e5f5; border-left: 4px solid #9C27B0; }
    .system { background: #fff3e0; border-left: 4px solid #FF9800; }
    .role { font-weight: bold; text-transform: uppercase; font-size: 0.85em; color: #555; margin-bottom: 0.5em; }
    .content { line-height: 1.6; }
    pre { background: #f5f5f5; padding: 1em; border-radius: 4px; overflow-x: auto; }
    code { background: #f0f0f0; padding: 0.2em 0.4em; border-radius: 3px; }
  </style>
</head>
<body>
  <h1>ChatGPT Export</h1>
`;

      conversationsData.forEach((conv, index) => {
        html += `  <div class="conversation">
    <div class="title">${escapeHtml(getConversationTitle(conv, index))}</div>
    <div class="meta">${getConversationDate(conv)}</div>
`;
        const messages = extractMessages(conv);
        messages.forEach(msg => {
          if (msg.role && msg.content) {
            html += `    <div class="message ${msg.role}">
      <div class="role">${msg.role}</div>
      <div class="content">${formatContent(msg.content)}</div>
    </div>
`;
          }
        });
        html += `  </div>\n`;
      });

      html += `</body>
</html>`;
      return html;
    }

    function downloadFile(content, filename, mimeType) {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.setAttribute('aria-label', `Download ${filename}`);
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      const message = typeof i18n !== 'undefined'
        ? i18n.t('downloaded', { filename })
        : `Downloaded ${filename}`;
      showStatus('success', message);
    }

    function loadDemoData() {
      fileName.textContent = 'sample-chatgpt-export.json (Demo)';
      const loadingMsg = typeof i18n !== 'undefined' ? i18n.t('loadingDemo') : 'Loading demo data...';
      showStatus('info', loadingMsg);
      
      // Load the sample data file
      fetch('sample-chatgpt-export.json')
        .then(response => response.json())
        .then(data => {
          processExportData(data);
        })
        .catch(error => {
          const errorMsg = typeof i18n !== 'undefined'
            ? i18n.t('errorLoadingDemo', { error: error.message })
            : 'Error loading demo data: ' + error.message;
          showStatus('error', errorMsg);
        });
    }

    // Register Service Worker for PWA support
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
          .then((registration) => {
            console.log('Service Worker registered successfully:', registration.scope);
          })
          .catch((error) => {
            console.log('Service Worker registration failed:', error);
          });
      });
    }
  </script>
</body>
</html>
